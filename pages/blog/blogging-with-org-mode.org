#+title: Blogging With Org Mode

#+options: toc:nil
* Writing My Blogs with Org Mode
#+BEGIN_QUOTE
16 Feb, 2022 Â· 5 min
#+END_QUOTE

I used JSX to write my blogs, which helped me get the job done, but it was a
huge hassle. I had to worry about JSX syntax, bugs, CSS classes, etc. These
problems distracted me from the actual content creation.  After my blog files
were done, they ended up being a messy compilation filled with JSX syntax that
distracts the user from the actual text content.  This honestly demotivated me
from writing blogs

I knew I had to find a solution to this problem. Instead of using JSX, I had to
turn to my favorite markup language to do the work: Org Mode

** What is Org Mode?
Org Mode (also /org-mode/) is a type of markup language used in Emacs. I love
org-mode because its very versatile in what it can do. I use to to take notes,
write documents, make an agenda, and develop websites. It's my preferred markup
language over Markdown (which I will explain more in a future blog)

** Setup / Methods
Since there isn't really a dedicated package that converts org-mode to JSX, I had to resort to writing my documents in org-mode first, then exporting them to Markdown

There are many packages that can help parse org-files into JSX, like =react-markdown= and =markdown-to-jsx=. Since I am using the Vite engine to build
this React app, I use the [[https://github.com/geekris1/vite-plugin-react-markdown][vite-plugin-react-markdown]] package for this website

Once this package is installed, I had to configure my =vite.config.js= file to
utilize the package and allow the app to include Markdown files

#+begin_src js
// vite.config.js
import { defineConfig } from 'vite';
import Markdown from 'vite-plugin-react-markdown';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [
    Markdown(),
    react({
      include: [/\.tsx$/, /\.md$/], // <-- add .md
    }),
  ],
});
#+end_src

Inside of my =Routes.js= file, I set it up so that each blog post has a prop
that has the name of the Markdown file

#+begin_src js
// Routes.js
...
  {
    path: '/blog/volunteering-with-tzu-chi',
    key: 'Volunteering with Tzu Chi',
    component: BlogPostView,
    props: {
      title: `Volunteering with the Tzu Chi Foundation ${suffix}`,
      markdownFile: 'volunteering-tzu-chi',
    },
  },
...
#+end_src

When rendering my routes, I ensure that these props are passed into the components

#+begin_src js
import ROUTES from './Routes';
const RenderRoutes = () => {
  const location = useLocation();

  return (
    <Switch location={location} key={location.pathname}>
      {ROUTES.map((route) => (
        <Route
          path={route.path}
          key={route.key}
          exact={true}
          render={(props) => {
            <route.component {...props} {...route.props} />}
          }
      ))}
    </Switch>
  );
};

export default RenderRoutes;

#+end_src

For my blog posts, I set up a component called =BlogPostView= that retrieves a
Markdown file and parses it to JSX.

#+begin_src js
import React, { useEffect, useState } from 'react';
import './BlogPostView.css';

const BlogPostView = ({ markdownFile, title }) => {
  const [content, setContent] = useState(null);

  useEffect(() => {
    import(`../../../pages/blog/${markdownFile}.md`)
      .then((res) => {
        setContent(res.default);
      })
      .catch((err) => {
        console.log(`Failed to import Markdown: ${err}`);
      });
  }, [markdownFile]);

  return (
    {content && <>{content}</>}
  );
};

export default BlogPostView;
#+end_src

For my method, I set up a state called =content=. Once the component loads, it retrieves the Markdown file from the prop that was passed in. Once it is able to retrieve the data, then the component sets the state of that data to =content=

#+begin_src js
const BlogPostView = ({ markdownFile, title }) => {
  const [content, setContent] = useState(null);

  useEffect(() => {
    import(`../../../pages/blog/${markdownFile}.md`)
      .then((res) => {
        setContent(res.default);
      })
      .catch((err) => {
        console.log(`Failed to import Markdown: ${err}`);
      });
  }, [markdownFile]);

...
#+end_src

** CSS
When exporting Markdown to HTML, several HTML elements are commonly used to
represent different Markdown constructs. For example:

1. Headings
   + Markdown: =# Heading 1=
   + HTML: =<h1>Heading 1</h1>=
2. Paragraphs:
    + Markdown: =This is a paragraph.=
    + HTML: =<p>This is a paragraph.</p>=

org-mode doesn't have a way to apply CSS classes to be exported to Markdown.
Instead, I have to use element selectors to apply my styles. Below is a snippet
of my =BlogPostView.css= file of the kinds of styles I apply. Note: the =vite-plugin-react-markdown= class is used from the package, so I utilize that to
apply my styles

#+begin_src css
/* BlogPostView.css */
.vite-plugin-react-markdown h1 {
  text-align: center;
  margin-top: 200px;
}

.vite-plugin-react-markdown h2 {
  margin-top: 4rem;
  font-size: 2.4rem;
  text-transform: capitalize;
}

.vite-plugin-react-markdown pre {
  background-color: #363636;
}

.vite-plugin-react-markdown pre code {
  font-size: 1rem;
  overflow-x: auto;
  white-space: pre-wrap;
}
#+end_src

** Issues I've Encountered (and Solutions to Them)
*** Images
org-mode doesn't have a way to export alt tags on images to Markdown

#+begin_src
// org-mode
[[example.png][an example alt]]

// exported md file
![img](example.png)
#+end_src

To get around this, I just had to include the exclamation symbol at the beginning of the org image line

#+begin_src
// org-mode
![[example.png][an example alt]]

// exported md file
![an example alt](example.png)
#+end_src

*** The =import= statement
This problem is specific if you're using Vite and =vite-plugin-react-markdown=.
If you're using a different method to rendering Markdown, ignore this section

When using dynamic imports, they must end with a file extension. From the =rollup=
docs, in order to avoid unintended imports of files within a folder, it is
necessary for imports to conclude with a file extension within the static
portions of the import. This ensures that only the intended files are included
in the import process.

#+begin_src js
// Not allowed
import(`./foo/${bar}`);

// allowed
import(`./foo/${bar}.js`);
#+end_src

I had my import similar to the one below, which caused errors:

#+begin_src js
import(`./path/to/markdownFile/${markdownFile}`)
#+end_src

Therefore, I had to change my import to this:

#+begin_src js
import(`./path/to/markdownFile/${markdownFile}.md`)
#+end_src

** Conclusion
